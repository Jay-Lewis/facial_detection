# -*- coding: utf-8 -*-
"""boundingbox_mnist_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gRpSMEcT0lOgSeA69YXxDW5hFLAOMFrV
"""

# Gathering libraries


import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow import data as tfds 
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

import pandas as pd

# Getting our data

!wget "https://github.com/Jay-Lewis/facial_detection/tree/master/Mnist_detection/dataset/no%20transformations/test_set.csv"
!wget "https://github.com/Jay-Lewis/facial_detection/tree/master/Mnist_detection/dataset/no%20transformations/training_set.csv"

# IOU (intersection over union) is a good measure of the accuracy of a bounding box
# Remember that the format of the bounding box data is [x, y, w, h]
def IOU(bbox1, bbox2):
    w_I = min(bbox1[0] + bbox1[2], bbox2[0] + bbox2[2]) - max(bbox1[0], bbox2[2])
    h_I = min(bbox1[1] + bbox1[3], bbox2[1] + bbox2[3]) - max(bbox1[2], bbox2[2])
    w_I = max(w_I, 0)
    h_I = max(h_I, 0)

    if w_I <= 0 or h_I <= 0:
      return 0.

    I = w_I * h_I # Intersection

    U = bbox1[2] * bbox1[3] + bbox2[2] * bbox2[3] - I # Union

    return I / U

# One hot mnist

#mnist_onehot_class = np.zeros(img_count, object_count)

#for i in range(img_count):
#  for j in range(object_count):

# And now for the model...

pool_size = 2

model = models.Sequential([
                           layers.Conv2D(32, kernel_size = 6, strides = (1,1), activation = 'relu'),   # Edge detection stage
                           layers.MaxPool2D(pool_size = (pool_size, pool_size)),
                           layers.Flatten(),
                           layers.Dropout(0.2),
                           layers.Dense(256, activation = 'relu')])

model.compile('adadelta','mse')

# Form our training and test sets

# Training...


num_epochs = 50

model.fit(x_train, y_train, epochs = num_epochs, validation_data = (x_test, y_test))
pred_y = model.predict(x_train)

  # I found some cool code that deals with flipping - this is without flipping, and
  # is only used for calculating IOUs. Uncomment if you want that.
  # CURRENTLY INCOMPLETE

  '''
  for sample, (pred_bboxes, exp_bboxes) in enumerate(zip(pred_y, y_train))
    pred_bboxes = pred_bboxes.reshape(num_objects, -1)
    exp_bboxes = exp_bboxes.reshape(num_objects, -1)

    for exp_bbox, pred_bbox in zip(exp_bboxes, pred_bboxes):
      # iterate epochs here
  '''